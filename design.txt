The following source files are relevant to the sender application:
1. userinput.[ch]
2. setup.[ch]
3. packet.[ch]
4. senderfcns.[ch]

The following source files are relevant to the receiver application:
1. setup.[ch]
2. packet.[ch]
3. receiverfcns.[ch]

The following source files are relevant to the forwarder application:
1. setup.[ch]
2. packet.[ch]
3. userinput.[ch]
4. fwdsend.[ch]
5. fwdrec.[ch]


Description of source files:

1. setup.[ch]
    
   These sources files contain function calls for setting up active and
   passive UDP and TCP sockets. Additionally they define a struct SOCK_INFO
   that is used to hold newly created socket file descriptors, as well as
   sender/receiver infomation in the case of UDP sockets.

2. packet.[ch]
   
   Packet.h defines a macro to for the maximum message size,
   MAXBUF, that can be entered by the user. As such, when entering messages
   into the sender program, the maximum message length is 100 characters.
   Additionally this file defines the macros ACKSZ and PKTSZ, that define the
   size of an ack and a packet respectively.

   Packet.h defines a struct packet that defines a packet. A packet contains
   3 fields: a sequence number, a message buffer, and a time stamp for when
   the message was sent to the receiver.

   Lastly, the files define a function that creates a new packet.

3. userinput.[ch]

   Userinput.[ch] define a function checkinput() that is used to verify
   the following when using the sender/forwarder applications:

   a) 5 command line arguments were entered
   b) The ip address was a valid IPv4 or IPv6 address
   c) The maximum window size is an integer greater than 0
   d) The timeout value is an integer greater than 0

4. senderfcns.[ch]

   These files contain the code that will carry out all necessary operation
   related to the go-back-n sliding window protocol for the sender application.
   
   This file contains a queue of packets waiting for acks or to be sent
   to the receiver. Additionally, it has varibles that track the following
   values: bottom of sending window, window size, current sequence number,
   timeout value of the oldest unacked message.

   Two setup function are defined. Sender_init() initializes the queue and
   the variables described above. Setup_pfds() initializes an array of
   struct pollfd to be used by the poll function in the main() function
   defined in sender.c
    
   Sender_input() handles the instance where a user enters a message. The
   message will be placed in a packet, along with an associated sequence
   number. If the sending window is not full, the message will be sent to
   the user and added to the queue of unacked/unsent messages. If the
   sending window is full, the message will be added to the queue and sent
   once its sequence number enters the sending window.

   Sender_ack() handles the instance where the receiver sends an ack
   for a message. The funcion will remove messages from the queue until
   the message with the sequence number being acked is found. This
   allows for cumulative acks, as specified by the  go-back-n sliding window
   protocol. After the message(s) being acked have been removed from the
   queue, if there are unsent message in the queue, messages will be
   sent to the receiver either until there are no more unsent messages,
   or the sending window is full.

   Sender_timeout() is called when the timeout value the poll function
   times out, indicating the user has not entered any new messages and
   the receiver has not sent any new acks. The function iterates through
   the queue, starting with the oldest unacked message and resends messages
   until there are no unsent messages, or the sending window is full.

   Calc_timeout() is a helper function used to calculate the timeout value
   for the oldest unacked message when a new message is inputted by the
   user or an ack is received.  


5. receiverfcns.[ch]

   These files contain the code that will carry out all necessary operations
   related to the go-back-n sliding window protocol for the receiver
   application.

   These files contain variables to track the following values: the next
   expected sequence number, the last received sequence number, the
   probability an ack will be sent.

   Rec_init() is to be called in receiver.c before and messages are received
   or acks sent.

   Parse_pkt() takes a newly received packet and determines if it is the
   packet with the next expected sequence number, a retransmission of the
   last correctly received packet, or an out of order packet. The return
   value is then used by receiver.c to determine which operation to
   execute.

   Rec_next() is used when the received packet contains the next in order 
   sequence number. The sequence number and the message will be printed
   to stdout and the probabiity of the ack being sent is calculated.
   If yes, the ack is sent to the sender. If no, a message to stdout
   indicates the ack for that sequence number was not sent.

   Rec_retransmission() handles the instance where a retransmission of
   the last correctly received packet occurs. The packets message and 
   sequence number, along with a messsage indicating it was a retrans-
   mission are printed to stdout. The probabilty of sending the ack is
   calculated. If yes, we sent the ack, otherwise a message is printed
   indicated the ack wasn't sent.

   Pkt_recvd() prompts the user in indicate if the packet is received
   or not. This function is used by rec_next() to determine whether
   we keep the current packet, or if it is discarded.

   Calc_prob() calculates the probability an ack will be sent to the sender.

6. fwdsend.[ch]

   These functions handle all parts of the forwarder than act as a sender.
   The the code for all functions is almost identical to the functions
   defined in senderfcns.c. The primary difference is that when an ack
   is received, fwd_input() fowards the ack to the sending application.

7. fwdrec.[ch]

   These functions handle all parts of the forwarder that act as a receiver.
   The code for all functions is almost identical to the functions
   defined in receiverfcns.c with the exception, when a retransmission
   is receiver, it is forwarded onto the receiver.

8. sender.c

   This file contains the main() function to run the program. The first
   portion simply calls all setup functions. Then, poll() is called.
   When poll returns, either a input from stdin a read, an ack is
   received, or a timeout occured. In all instances the appropriate
   function from senderfcns.c is called to carry out the operation.

9. receiver.c

   This file contains the main() function to run the program. The first
   portion simply calls all setup functions. The program then enters
   a main receive loop where is receives packets from the sender. The
   new packet is then parsed by parse_pkt() and the correct operation
   is carried out by the functions defined in receiverfcns.c

10. forwarder.c
  
   This file contains the main() function to run the forwarder program.
   Two sockets are created, one to send/recv packets from the sender and
   one to send/recv packets from the receiver. After setup, poll() is used
   to monitor the sockets. If a packet is received from the sender, the
   packet is parsed as done in the receiver application. Then the correct
   function is called from fwdrec.c to handle the packet. If the user
   decides to keep the packet, and it is the next in order, the packet
   is passed to the sender portion of the application, where it is handled
   by the function fwd_input(). If we get an ack from the received, the
   ack is processed by the sender portion of the application and then sent
   on to the sender.

11. queue.[ch]
  
   These files define a basic queue with the following operations:
   create, enqueue, dequeue, peek, size.
